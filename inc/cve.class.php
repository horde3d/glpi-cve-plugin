<?php
/*
 * -------------------------------------------------------------------------
 * CVE
 * Copyright (C) 2020-2021 by Curtis Conard
 * https://github.com/cconard96/glpi-cve-plugin
 * -------------------------------------------------------------------------
 * LICENSE
 * This file is part of CVE.
 * CVE is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * CVE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with CVE. If not, see <http://www.gnu.org/licenses/>.
 * --------------------------------------------------------------------------
 */

class PluginCveCve extends CommonGLPI {

   public static function getTypeName($nb = 0)
   {
      return _n('CVE', 'CVEs', $nb, 'cve');
   }

   public static function getMenuName()
   {
      return self::getTypeName(Session::getPluralNumber());
   }

   public function getTabNameForItem(CommonGLPI $item, $withtemplate = 0)
   {
      return self::createTabEntry(self::getTypeName(2));
   }

   public static function displayTabContentForItem(CommonGLPI $item, $tabnum = 1, $withtemplate = 0)
   {
      if ($item::getType() === Software::class) {
         return self::showForSoftware($item);
      }
      if ($item::getType() === SoftwareVersion::class) {
         return self::showForSoftwareVersion($item);
      }
      return false;
   }

   public static function getIcon() {
      return 'fas fa-shield-alt';
   }

   /**
    * Check if can view item
    *
    * @return boolean
    */
   static function canView() {
      return Config::canView();
   }

   private static function getAllSoftware(bool $include_glpi = false)
   {
      global $DB;

      $software_table = Software::getTable();
      $softwareversion_table = SoftwareVersion::getTable();
      $manufacturer_table = Manufacturer::getTable();

      $software_versions = $DB->request([
         'SELECT'    => [
            'glpi_softwares.name AS product',
            'glpi_softwareversions.name AS version',
            'glpi_manufacturers.name AS vendor'
         ],
         'FROM'      => $softwareversion_table,
         'LEFT JOIN' => [
            $software_table => [
               'FKEY'   => [
                  $softwareversion_table  => 'softwares_id',
                  $software_table         => 'id'
               ]
            ],
            $manufacturer_table => [
               'FKEY'   => [
                  $software_table      => 'manufacturers_id',
                  $manufacturer_table  => 'id'
               ]
            ]
         ]
      ]);
      $results = [];
      foreach ($software_versions as $data) {
         $results[] = $data;
      }
      if ($include_glpi) {
         $results[] = [
            'software'  => 'GLPI',
            'vendor' => 'GLPI-Project',
            'version'   => GLPI_VERSION
         ];
      }
      return $results;
   }

   private static function array_get($array, $keys, $default = 'N/A') {
      foreach ($keys as $key) {
         if (!array_is_list($array) && is_int($key) )
            $key = array_keys($array)[$key];
         if (!isset($array[$key])) {
            /*
             *                  echo "$key from ";
             *                  var_dump($keys);
             *                  echo " not found in <br>";
             *                  var_dump($array);
             *                  echo "<br><br>";
             *                  //echo "Stopped at $key".PHP_EOL."<br>";
             */
            return $default;
         }
         $array = $array[$key];
      }
      return $array;
   }

   private static function isAffected($versionToCheck, $affectedVersion) {
      if (trim(strtolower($affectedVersion)) === 'n/a') {
         //echo "Undetermined version: $affectedVersion<br>";
         return true;
      }
      // Split the range string by comma
      $conditions = explode(',', $affectedVersion);

      // Trim whitespace around each condition
      $conditions = array_map('trim', $conditions);

      // If only one condition without operator is provided, assume "<" comparison
      if (count($conditions) == 1 && !preg_match('/(>=|<=|>|<|=)/', $conditions[0])) {
         // Perform a simple version compare with "<"
         return version_compare($versionToCheck, $conditions[0], '<') < 1 ? false : true;
      }

      // Loop through each condition and check if the version satisfies it
      $isValid = true;

      foreach ($conditions as $condition) {
         // Split the condition into the operator and the version number
         if (preg_match('/(>=|<=|>|<|=)\s*(.*)/', $condition, $matches)) {
            $operator = $matches[1];
            $version = $matches[2];
            // Use version_compare to check the condition
            if (version_compare($versionToCheck, $version, $operator) < 1) {
               $isValid = false;
               break;
            }
         }
      }
      // Output the result
      return $isValid;
   }

   private static function formatCVEResults($results, $vendor = null, $product = null, $version = null)
   {
      $formatted = [];
      foreach ($results as $cve) {
         if (!is_array($cve)) {
            return [];
         }
         $cve_metadata = $cve[1]['cveMetadata'];
         $cve_cna = $cve[1]['containers']['cna'];
         $affectedVersions = self::array_get($cve_cna, ['affected', 0, 'versions'], NULL);
         $isAffected = is_null($version);
         if(!is_null($affectedVersions) && !is_null($version)) {
            foreach($affectedVersions as $affectedVersion) {
               $status = $affectedVersion['status'];
               if(array_key_exists('lessThan', $affectedVersion)) {
                  $versionRange = $affectedVersion['lessThan'];
               }
               else if(array_key_exists('version', $affectedVersion)) {
                  $versionRange = $affectedVersion['version'];
               }
               else {
                  echo "Skipping ";
                  var_dump($affectedVersion);
                  echo "<br>";
                  continue;
               }
               $isAffected = self::isAffected($version, $versionRange);
               /*                if (!self::isAffected($version, $versionRange))
                *                {
                *                    var_dump($version);
                *                    echo " not affected! Range: ";
                *                    var_dump($versionRange);
                *	            echo "<br>";
            }
            */
               if($isAffected)
                  break;
            }
         }
         if (!$isAffected)
            continue;

         //if (array_key_exists('metrics', $cve_cna))
         //    var_dump(reset($cve_cna['metrics'][0])['baseScore']);
         $result = [
            'date_mod'        => (new DateTime($cve_metadata['dateUpdated']))->format('Y-m-d'),
            'date_published'  => (new DateTime($cve_metadata['datePublished']))->format('Y-m-d'),
            'vendor'          => $vendor,
            'product'         => $product,
            'access'          => '???', //cve['access'],
            'assigner'        => $cve_metadata['assignerShortName'],
            'cvss'            => self::array_get($cve_cna, ['metrics',0,0,'baseScore'], -1), // $cve['cvss'],
            'cvss-time'       => '???', //$cve['cvss-time'],
            'cvss-vector'     => self::array_get($cve_cna, ['metrics',0,0,'vectorString']),
            'cwe'             => self::array_get($cve_cna, ['problemTypes',0,'descriptions',0,'cweId']),
            'id'              => $cve[0], // $cve['id'],
            'impact'          => '???', // $cve['impact'],
            'summary'         => htmlentities(self::array_get($cve_cna, ['descriptions',0,'value'])),
            'references'      => $cve_cna['references'][0]['url'],
            'vulnerable_configs' => []
         ];
         $vulnerable_configs = []; //$cve['vulnerable_configuration'];
         foreach ($vulnerable_configs as $vulnerable_config) {
            if (is_array($vulnerable_config)) {
               $vulnerable_config = $vulnerable_config['id'];
            }
            list($cpe_name, $cpe_version, $cpe_part, $svendor, $sproduct, $sversion, $stability, $platform) = explode(':', $vulnerable_config);
            if ($result['vendor'] === null) {
               $result['vendor'] = $svendor;
            }
            if ($result['product'] === null) {
               $result['product'] = $sproduct;
            }
            $result['vulnerable_configs'][] = [
               'cpe_name'     => $cpe_name,
               'cpe_version'  => $cpe_version,
               'vendor'       => $svendor,
               'product'      => $sproduct,
               'version'      => $sversion,
               'stability'    => $stability,
               'platform'     => $platform
            ];
         }
         $formatted[] = $result;
      }
      return $formatted;
   }

   public static function getCVSSBackgroundColor(float $cvss_score): string
   {
      if ($cvss_score === 0) {
         return 'transparent';
      }

      if ($cvss_score > 0 && $cvss_score < 4) {
         return 'lightblue';
      }

      if ($cvss_score >= 4 && $cvss_score < 7) {
         return 'yellow';
      }

      if ($cvss_score >= 7 && $cvss_score < 9) {
         return 'orange';
      }

      if ($cvss_score >= 9) {
         return 'red';
      }
      return 'red';
   }

   /**
    * @param array $results
    * @return string
    */
   public static function getCVETable(array $results): string
   {
      //var_dump($results);
      $number = count($results);
      $start = 0;
      $out = '';
      $out .= "<div class='spaced'>";
      if ($number) {
         $out .= Html::printAjaxPager('', $start, $number, '', false);

         $out .= "<table class='tab_cadre_fixe'>";
         $out .= "<tr>";
         $out .= "<th>".__('CVE ID', 'cve')."</th>";
         $out .= "<th>".__('Date Published', 'cve')."</th>";
         $out .= "<th>".__('Date Modified', 'cve')."</th>";
         $out .= "<th>".__('Publisher', 'cve')."</th>";
         $out .= "<th>".__('Product', 'cve')."</th>";
         $out .= "<th>".__('Summary', 'cve')."</th>";
         $out .= "<th>".__('CVSS', 'cve')."</th>";
         $out .= "</tr>";

         foreach ($results as $result) {
            $out .= '<tr class="tab_bg_1">';
            $out .= "<td><a target='_blank' href={$result['references']}>{$result['id']}</a></td>";
            $out .= "<td>{$result['date_published']}</td>";
            $out .= "<td>{$result['date_mod']}</td>";
            $out .= "<td>{$result['vendor']}</td>";
            $out .= "<td>{$result['product']}</td>";
            $out .= "<td>{$result['summary']}</td>";
            $cvss = (float) $result['cvss'];
            $cvss_color = self::getCVSSBackgroundColor($cvss);
            $out .= "<td class='center' style='background-color: {$cvss_color}; color: black; font-weight: bold; font-size: 1.2em'>{$cvss}</td>";
            $out .= '</tr>';
         }
         $out .= '</table>';
      } else {
         $out .= "<p class='center b'>".__('No item found')."</p>";
      }
      $out .= "</div>";

      return $out;
   }

   public static function showCVEs()
   {
      $software_data = self::getAllSoftware(true);
      $results = [];

      foreach ($software_data as $data) {
         if (empty($data['vendor'])) {
            echo "Skipping ";
            var_dump($data);
            echo "<br>";
            continue;
         }
         if (array_key_exists('software', $data))
            $product = $data['software'];
         else if(array_key_exists('product', $data))
            $product = $data['product'];
         else {
            echo "Skipping unknown values from ";
            var_dump($data);
            echo "<br>";
            continue;
         }
         try {
            $cves = PluginCveApi::getCVEByVendorAndProduct($data['vendor'], $product);
         }
         catch(Exception $e) {
            switch($e->getCode()) {
               case 404:
                  echo "API not supported for ".$data['vendor']. " $product <br>";
                  $cves = [];
                  // TODO try to get information  via  PluginCveApi::getCVEByVendorAndProduct
                  break;
               default:
                  echo "HTTP Code: ".$e->getCode()." returned<br>"; // TODO make this a proper GLPI message
                  $cves = [];
                  break;
            }
         }

         if (!count($cves) || empty($cves['cvelistv5']) || !is_array($cves['cvelistv5'])) {
            continue;
         }
         $results = array_merge($results, self::formatCVEResults($cves['cvelistv5'], $data['vendor'], $product, $data['version']));
      }

      usort($results, static function($result1, $result2){
         $publish_1 = strtotime($result1['date_published']);
         $publish_2 = strtotime($result2['date_published']);
         if ($publish_1 < $publish_2) {
            return -1;
         } else if ($publish_1 > $publish_2) {
            return 1;
         } else {
            return 0;
         }
      });
      $results = array_reverse($results);
      echo self::getCVETable($results);
   }

   public static function showForSoftware(CommonGLPI $item)
   {
      global $DB;

      $software_table = Software::getTable();
      $manufacturer_table = Manufacturer::getTable();

      $software_versions = $DB->request([
         'SELECT'    => [
            'glpi_softwares.name AS product',
            'glpi_manufacturers.name AS vendor'
         ],
         'FROM'      => $software_table,
         'LEFT JOIN' => [
            $manufacturer_table => [
               'FKEY'   => [
                  $software_table      => 'manufacturers_id',
                  $manufacturer_table  => 'id'
               ]
            ]
         ],
         'WHERE'  => [
            'glpi_softwares.id'  => $item->getID()
         ]
      ]);

      $data = $software_versions->current();
      $results = [];

      //var_dump($data);
      if (!empty($data['vendor'])) {
         $cpe_code = PluginCveApi::formCPE2_3String('a', PluginCveApi::formatVendorName($data['vendor']),
                                                    PluginCveApi::formatProductName($data['product']));

         try {
            $cves = PluginCveApi::getCVEForCPE($cpe_code);
         }
         catch(Exception $e) {
            switch($e->getCode()) {
               case 404:
                  echo "API not supported<br>";
                  $cves = [];
                  // TODO try to get information  via  PluginCveApi::getCVEByVendorAndProduct
                  break;
               default:
                  echo "HTTP Code: ".$e->getCode()." returned<br>"; // TODO make this a proper GLPI message
                  $cves = [];
                  break;
            }
         }

         if (count($cves)) {
            $results = self::formatCVEResults($cves, $data['vendor'], $data['product']);
         }
      }

      usort($results, static function($result1, $result2){
         $publish_1 = strtotime($result1['date_published']);
         $publish_2 = strtotime($result2['date_published']);
         if ($publish_1 < $publish_2) {
            return -1;
         } else if ($publish_1 > $publish_2) {
            return 1;
         } else {
            return 0;
         }
      });
      $results = array_reverse($results);

      echo self::getCVETable($results);
   }

   public static function showForSoftwareVersion(CommonGLPI $item)
   {
      global $DB;

      $software_table = Software::getTable();
      $softwareversion_table = SoftwareVersion::getTable();
      $manufacturer_table = Manufacturer::getTable();
      /*
       *      echo "SELECT $software_table.name AS product, <br>";
       *      echo "$softwareversion_table.name AS version, <br>";
       *      echo "$manufacturer_table.name AS vendor <br>";
       *      echo "FROM $softwareversion_table <br>";
       *      echo "LEFT JOIN  $software_table <br>";
       *      echo "WHERE $softwareversion_table.id = ".$item->getID()."<br>";
       */
      $software_versions = $DB->request([
         'SELECT'    => [
            $software_table.'.name AS product',
            $softwareversion_table.'.name AS version',
            $manufacturer_table.'.name AS vendor'
         ],
         'FROM'      => $softwareversion_table,
         'LEFT JOIN' => [
            $software_table => [
               'FKEY'   => [
                  $softwareversion_table  => 'softwares_id',
                  $software_table         => 'id'
               ]
            ],
            $manufacturer_table => [
               'FKEY'   => [
                  $software_table      => 'manufacturers_id',
                  $manufacturer_table  => 'id'
               ]
            ]
         ],
         'WHERE'  => [
            $softwareversion_table.'.id'  => $item->getID()
         ]
      ]);

      $data = $software_versions->current();
      $results = [];
      //var_dump($data);
      if (!empty($data['vendor'])) {
         $cpe_code = PluginCveApi::formCPE2_3String('a', PluginCveApi::formatVendorName($data['vendor']),
                                                    PluginCveApi::formatProductName($data['product']), $data['version']);
         try {
            $cves = PluginCveApi::getCVEForCPE($cpe_code);
         }
         catch(Exception $e) {
            switch($e->getCode()) {
               case 404:
                  echo "API not supported<br>";
                  $cves = [];
                  // TODO try to get information  via  PluginCveApi::getCVEByVendorAndProduct
                  break;
               default:
                  echo "HTTP Code: ".$e->getCode()." returned<br>"; // TODO make this a proper GLPI message
                  $cves = [];
                  break;
            }
         }

         if (count($cves)) {
            $results = self::formatCVEResults($cves, $data['vendor'], $data['product']); // TODO check if we can reference the software from $data here
         }
      }

      usort($results, static function($result1, $result2){
         $publish_1 = strtotime($result1['date_published']);
         $publish_2 = strtotime($result2['date_published']);
         if ($publish_1 < $publish_2) {
            return -1;
         } else if ($publish_1 > $publish_2) {
            return 1;
         } else {
            return 0;
         }
      });
      $results = array_reverse($results);

      echo self::getCVETable($results);
   }

   public static function dashboardCards()
   {
      $cards = [];


      $cards["plugin_cve_latest_all"] = [
         'widgettype'  => ['articleList'],
         'label'       => 'Latest CVEs',
         'provider'    => 'PluginCveCve::cardProvider',
      ];

      return $cards;
   }

   public static function cardProvider($name = '', array $params = [])
   {
      $recent = PluginCveApi::getRecentCVE(10);
      $card_data = [];
      foreach ($recent as $data) {
         $card_data[] = [
            'label'     => self::array_get($data, ['vulnerabilities',0,'cve'], "N/A"),
            'content'   => self::array_get($data, ['vulnerabilities',0,'notes',0,'text'], "N/A"),
            'date'      => self::array_get($data, ['vulnerabilities',0,'discovery_date'], "N/A"),
            'author'    => '',
            'url'       => self::array_get($data, ['vulnerabilities',0,'references',0,'url'], ""),
         ];
      }
      return [
         'label' => 'Latest CVEs',
         'data'  => $card_data,
         'number' => 10,
         'url'    => '',
         'icon'   => ''
      ];
   }
}
