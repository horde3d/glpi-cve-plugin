<?php
/*
 * -------------------------------------------------------------------------
 * CVE
 * Copyright (C) 2020-2021 by Curtis Conard
 * https://github.com/cconard96/glpi-cve-plugin
 * -------------------------------------------------------------------------
 * LICENSE
 * This file is part of CVE.
 * CVE is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * CVE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with CVE. If not, see <http://www.gnu.org/licenses/>.
 * --------------------------------------------------------------------------
 */

if (!function_exists('array_is_list')) {
   function array_is_list(array $arr)
   {
      if ($arr === []) {
         return true;
      }
      return array_keys($arr) === range(0, count($arr) - 1);
   }
}


class PluginCveCve extends CommonGLPI {

   public static function getTypeName($nb = 0)
   {
      return _n('CVE', 'CVEs', $nb, 'cve');
   }

   public static function getMenuName()
   {
      return self::getTypeName(Session::getPluralNumber());
   }

   public function getTabNameForItem(CommonGLPI $item, $withtemplate = 0)
   {
      return self::createTabEntry(self::getTypeName(2));
   }

   public static function displayTabContentForItem(CommonGLPI $item, $tabnum = 1, $withtemplate = 0)
   {
      if ($item::getType() === Software::class) {
         return self::showForSoftware($item);
      }
      if ($item::getType() === SoftwareVersion::class) {
         return self::showForSoftwareVersion($item);
      }
      return false;
   }

   public static function getIcon() {
      return 'fas fa-shield-alt';
   }

   /**
    * Check if can view item
    *
    * @return boolean
    */
   static function canView() {
      return Config::canView();
   }

   private static function getAllSoftware(bool $include_glpi = false)
   {
      global $DB;

      $software_table = Software::getTable();
      $softwareversion_table = SoftwareVersion::getTable();
      $manufacturer_table = Manufacturer::getTable();

      $software_versions = $DB->request([
         'SELECT'    => [
            $software_table.'.id AS internal_id',
            $software_table.'.name AS product',
            $softwareversion_table.'.name AS version',
            $manufacturer_table.'.name AS vendor'
         ],
         'FROM'      => $softwareversion_table,
         'LEFT JOIN' => [
            $software_table => [
               'FKEY'   => [
                  $softwareversion_table  => 'softwares_id',
                  $software_table         => 'id'
               ]
            ],
            $manufacturer_table => [
               'FKEY'   => [
                  $software_table      => 'manufacturers_id',
                  $manufacturer_table  => 'id'
               ]
            ]
         ]
      ]);
      $results = [];
      foreach ($software_versions as $data) {
         $results[] = $data;
      }
      if ($include_glpi) {
         $results[] = [
            'internal_id' => '0',
            'software'  => 'GLPI',
            'vendor' => 'GLPI-Project',
            'version'   => GLPI_VERSION
         ];
      }
      return $results;
   }

   private static function array_get($array, $keys, $default = 'N/A') {
      foreach ($keys as $key) {
         if (!array_is_list($array) && is_int($key) )
            $key = array_keys($array)[$key];
         if (!isset($array[$key])) {
            /*
             *                  echo "$key from ";
             *                  var_dump($keys);
             *                  echo " not found in <br>";
             *                  var_dump($array);
             *                  echo "<br><br>";
             *                  //echo "Stopped at $key".PHP_EOL."<br>";
             */
            return $default;
         }
         $array = $array[$key];
      }
      return $array;
   }

   /**
    * Try to figure out if the version installed is affected by the version string provided by the CVE information
    */
   private static function isAffected($versionToCheck, $affectedVersion, $singleCompare = '<') {
      if (trim(strtolower($affectedVersion)) === 'n/a' || trim($affectedVersion) === '-' || trim($affectedVersion) === '*') {
         return true;
      }
      // Split the range string by comma
      $conditions = explode(',', $affectedVersion);

      // Trim whitespace around each condition
      $conditions = array_map('trim', $conditions);

      // If only one condition without operator is provided, assume "<" comparison
      if (count($conditions) == 1 && !preg_match('/(>=|<=|>|<|=)/', $conditions[0])) {
         //error_log("Comparing: $versionToCheck $singleCompare $affectedVersion");
         // Perform a simple version compare with "<"
         return version_compare($versionToCheck, $conditions[0], $singleCompare) < 1 ? false : true;
      }

      // Loop through each condition and check if the version satisfies it
      $isValid = true;

      foreach ($conditions as $condition) {
         // Split the condition into the operator and the version number
         if (preg_match('/(>=|<=|>|<|=)\s*(.*)/', $condition, $matches)) {
            $operator = $matches[1];
            $version = $matches[2];
            // Use version_compare to check the condition
            if (version_compare($versionToCheck, $version, $operator) < 1) {
               $isValid = false;
               break;
            }
         }
      }
      // Output the result
      return $isValid;
   }

   // Parsing function for https://vulnerability.circl.lu/
   private static function parseCnaResult($cve, $version)
   {
      $isAffected = is_null($version);
      $cve_metadata = $cve[1]['cveMetadata'];
      $cve_cna = $cve[1]['containers']['cna'];
      $affectedVersions = self::array_get($cve_cna, ['affected', 0, 'versions'], NULL);
      if(!is_null($affectedVersions) && !is_null($version)) {
         foreach($affectedVersions as $affectedVersion) {
            $defaultCompare = '=';
            $status = $affectedVersion['status'];
            if(array_key_exists('lessThan', $affectedVersion)) {
               $versionRange = $affectedVersion['lessThan'];
               $defaultCompare = '<';
            }
            else if(array_key_exists('version', $affectedVersion)) {
               $versionRange = $affectedVersion['version'];
            }
            else {
               error_log("Skipping unknown Version ".print_r($affectedVersion));
               continue;
            }
            $isAffected = self::isAffected($version, $versionRange, $defaultCompare);
            // If we found one affected version, we're done
            if($isAffected)
               break;
         }
      }
      // if we don't get information about affected versions, we assume it is affected
      else
         $isAffected = true;
      // skip entry if not affected
      if (!$isAffected)
         return [];

      // Initialize an empty array to store URLs
      $urls = [];

      // Iterate over each reference in $cve_cna['references']
      foreach ($cve_cna['references'] as $reference) {
         if (isset($reference['url'])) {
            // Append the 'url' field to the $urls array
            $urls[] = $reference['url'];
         }
      }

      $result = [
         'date_mod'        => (new DateTime($cve_metadata['dateUpdated']))->format('Y-m-d'),
         'date_published'  => (new DateTime($cve_metadata['datePublished']))->format('Y-m-d'),
         'vendor'          => $vendor,
         'product'         => $product,
         'access'          => '???', //cve['access'],
         'assigner'        => $cve_metadata['assignerShortName'],
         'cvss'            => self::array_get($cve_cna, ['metrics',0,0,'baseScore'], -1), // $cve['cvss'],
         'cvss-time'       => '???', //$cve['cvss-time'],
         'cvss-vector'     => self::array_get($cve_cna, ['metrics',0,0,'vectorString']),
         'cwe'             => self::array_get($cve_cna, ['problemTypes',0,'descriptions',0,'cweId']),
         'id'              => $cve[0], // $cve['id'],
         'impact'          => '???', // $cve['impact'],
         'summary'         => htmlentities(self::array_get($cve_cna, ['descriptions',0,'value'])),
         'references'      => $urls,
         'vulnerable_configs' => [] // TODO
      ];
      return $result;
   }

   // Parsing function for self-hosted cve-search
   private static function parseCveSearchResult($cve, $vendor, $product, $version)
   {
      if (!is_array($cve)) {
         //error_log("No array", 0);
         return [];
      }
      $isAffected = is_null($version);
      $defaultCompare = '=';
      $result = [
         'date_mod'        => (new DateTime($cve['modified']))->format('Y-m-d'),
         'date_published'  => (new DateTime($cve['published']))->format('Y-m-d'),
         'vendor'          => $vendor,
         'product'         => $product,
         'access'          => $cve['access'],
         'assigner'        => $cve['assigner'],
         'cvss'            => $cve['cvss'],
         'cvss-time'       => $cve['cvssTime'],
         'cvss-vector'     => $cve['cvssVector'],
         'cwe'             => $cve['cwe'],
         'id'              => $cve['id'],
         'impact'          => $cve['impact'],
         'summary'         => htmlentities($cve['summary']),
         'references'      => $cve['references'],
         'vulnerable_configs' => []
      ];
      $vulnerable_configs = $cve['vulnerable_configuration'];

      foreach ($vulnerable_configs as $vulnerable_config) {
         if (is_array($vulnerable_config)) {
            $vulnerable_config = $vulnerable_config['id'];
         }
         list($cpe_name, $cpe_version, $cpe_part, $svendor, $sproduct, $sversion, $stability, $platform) = explode(':', $vulnerable_config);
         if (trim($sversion) === '*' || trim($sversion) === '-' ) {
            error_log("Undefined version in CPE entry. Skipping $vulnerable_config", 0);
            continue;
         }
         if (PluginCveApi::formatVendorName($product) !== $sproduct || PluginCveApi::formatVendorName($vendor) !== $svendor) {
            error_log("Skipping $product - $vendor because not equal to vulnerable config: $sproduct - $svendor", 0);
            continue;
         }
         if ($result['vendor'] === null) {
            $result['vendor'] = $svendor;
         }
         if ($result['product'] === null) {
            $result['product'] = $sproduct;
         }

         $isAffected = $isAffected || self::isAffected($version, $sversion, $defaultCompare);
         if ($isAffected) {
            error_log("$svendor $sproduct vulnerable version == $sversion: $vulnerable_config");
            $result['vulnerable_configs'][] = [
               'cpe_name'     => $cpe_name,
               'cpe_version'  => $cpe_version,
               'vendor'       => $svendor,
               'product'      => $sproduct,
               'version'      => $sversion,
               'stability'    => $stability,
               'platform'     => $platform
            ];
         }
      }
      if (!$isAffected)
         return [];

      return $result;
   }

   private static function formatCVEResults($results, $internal_id = null, $vendor = null, $product = null, $version = null)
   {
      $formatted = [];
      foreach ($results as $cve) {
         if (array_is_list($cve))
            $result = self::parseCnaResult($cve);
         else
            $result = self::parseCveSearchResult($cve, $vendor, $product, $version);

         if(empty($result))
            continue;

         $result['internal_id'] = $internal_id;
         $formatted[] = $result;
      }
      return $formatted;
   }

   public static function getCVSSBackgroundColor(float $cvss_score): string
   {
      if ($cvss_score === 0) {
         return 'transparent';
      }

      if ($cvss_score > 0 && $cvss_score < 4) {
         return 'lightblue';
      }

      if ($cvss_score >= 4 && $cvss_score < 7) {
         return 'yellow';
      }

      if ($cvss_score >= 7 && $cvss_score < 9) {
         return 'orange';
      }

      if ($cvss_score >= 9) {
         return 'red';
      }
      return 'red';
   }

   /**
    * @param array $results
    * @return string
    */
   public static function getCVETable(array $results): string
   {
      //var_dump($results);
      $number = count($results);
      $start = 0;
      $out = '';
      $out .= "<div class='spaced'>";
      if ($number) {
         $out .= Html::printAjaxPager('', $start, $number, '', false);

         $out .= "<table class='tab_cadre_fixe'>";
         $out .= "<tr>";
         $out .= "<th>".__('CVE ID', 'cve')."</th>";
         $out .= "<th>".__('Date Published', 'cve')."</th>";
         $out .= "<th>".__('Date Modified', 'cve')."</th>";
         $out .= "<th>".__('Publisher', 'cve')."</th>";
         $out .= "<th>".__('Product', 'cve')."</th>";
         $out .= "<th>".__('Version', 'cve')."</th>";
         $out .= "<th>".__('Summary', 'cve')."</th>";
         $out .= "<th>".__('CVSS', 'cve')."</th>";
         $out .= "</tr>";

         foreach ($results as $result) {
            $config_string = '';
            $versions = '';
            foreach ($result['vulnerable_configs'] as $vulnerable_config) {
               foreach ($vulnerable_config as $key => $value) {
                  if ($key == "version" )
                     $versions .= $value."\n";
                  $config_string .= $key . ': ' . $value . "; ";
               }
               $config_string .= '\n';
            }
            $out .= '<tr class="tab_bg_1">';
            if(!empty($result['references']))
               $out .= "<td><a target='_blank' href={$result['references'][0]}>{$result['id']}</a></td>";
            else
               $out .= "<td>{$result['id']}</td>";
            $out .= "<td>{$result['date_published']}</td>";
            $out .= "<td>{$result['date_mod']}</td>";
            $out .= "<td>{$result['vendor']}</td>";
            $itemlink = Toolbox::getItemTypeFormURL('Software')."?id=".$result['internal_id'];
            $out .= "<td><a href=\"{$itemlink}\">{$result['product']}</a></td>";
            $out .= "<td>{$versions}</td>";
            $out .= "<td>{$result['summary']}</td>";
            $cvss = floatval($result['cvss']);
            $cvss_color = self::getCVSSBackgroundColor($cvss);
            if($cvss <= 0.1)
               $cvss = "N/A";

            $out .= "<td title='{$config_string}' class='center' style='background-color: {$cvss_color}; color: black; font-weight: bold; font-size: 1.2em'>{$cvss}</td>";
            $out .= '</tr>';
         }
         $out .= '</table>';
         $out .= Html::printAjaxPager('', $start, $number, '', false);
      } else {
         $out .= "<p class='center b'>".__('No item found')."</p>";
      }
      $out .= "</div>";

      return $out;
   }

   public static function showCVEs()
   {
      // TODO consider $_GET['start']
      $software_data = self::getAllSoftware(true);
      $results = [];

      foreach ($software_data as $data) {
         if (empty($data['vendor'])) {
            error_log( "Skipping because of empty vendor: ".print_r($data, true));
            continue;
         }
         if (array_key_exists('software', $data))
            $product = $data['software'];
         else if(array_key_exists('product', $data))
            $product = $data['product'];
         else {
            error_log( "Skipping unknown values from ". print_r($data, true));
            continue;
         }
         try {
            $key = 'cve_for_'.base64_encode($data['vendor'].$product);
            if (isset($_SESSION[$key]))
               $cves = $_SESSION[$key];
            else
            {
               $cves = PluginCveApi::getCVEByVendorAndProduct($data['vendor'], $product);
               $_SESSION[$key] = $cves;
            }
         }
         catch(Exception $e) {
            switch($e->getCode()) {
               case 404:
                  echo "API not supported for ".$data['vendor']. " $product <br>";
                  $cves = [];
                  // TODO try to get information  via  PluginCveApi::getCVEByVendorAndProduct
                  break;
               default:
                  echo "HTTP Code: ".$e->getCode()." returned<br>"; // TODO make this a proper GLPI message
                  $cves = [];
                  break;
            }
         }

         if (!count($cves)) {
            continue;
         }
         if (array_key_exists('cvelistv5',$cves) && !empty($cves['cvelistv5']) && is_array($cves['cvelistv5']))
            $results = array_merge($results, self::formatCVEResults($cves['cvelistv5'], $data['internal_id'], $data['vendor'], $product, $data['version']));
         else if(!empty($cves['results']) && is_array($cves['results']))
            $results = array_merge($results, self::formatCVEResults($cves['results'], $data['internal_id'], $data['vendor'], $product, $data['version']));
      }

      usort($results, static function($result1, $result2){
         $publish_1 = strtotime($result1['date_published']);
         $publish_2 = strtotime($result2['date_published']);
         if ($publish_1 < $publish_2) {
            return -1;
         } else if ($publish_1 > $publish_2) {
            return 1;
         } else {
            return 0;
         }
      });
      $results = array_reverse($results);
      echo self::getCVETable($results);
   }

   public static function showForSoftware(CommonGLPI $item)
   {
      global $DB;

      $software_table = Software::getTable();
      $manufacturer_table = Manufacturer::getTable();

      $software_versions = $DB->request([
         'SELECT'    => [
            $software_table.'.id AS internal_id',
            $software_table.'.name AS product',
            $manufacturer_table.'.name AS vendor'
         ],
         'FROM'      => $software_table,
         'LEFT JOIN' => [
            $manufacturer_table => [
               'FKEY'   => [
                  $software_table      => 'manufacturers_id',
                  $manufacturer_table  => 'id'
               ]
            ]
         ],
         'WHERE'  => [
            $software_table.'.id'  => $item->getID()
         ]
      ]);

      $data = $software_versions->current();
      $results = [];

      //var_dump($data);
      if (!empty($data['vendor'])) {
         $cpe_code = PluginCveApi::formCPE2_3String('a', PluginCveApi::formatVendorName($data['vendor']),
                                                    PluginCveApi::formatProductName($data['product']));

         try {
            $cves = PluginCveApi::getCVEForCPE($cpe_code);
         }
         catch(Exception $e) {
            switch($e->getCode()) {
               case 404:
                  echo "API not supported<br>";
                  $cves = [];
                  // TODO try to get information  via  PluginCveApi::getCVEByVendorAndProduct
                  break;
               default:
                  echo "HTTP Code: ".$e->getCode()." returned<br>"; // TODO make this a proper GLPI message
                  $cves = [];
                  break;
            }
         }

         if (count($cves)) {
            $results = self::formatCVEResults($cves, $data['internal_id'], $data['vendor'], $data['product']);
         }
      }

      usort($results, static function($result1, $result2){
         $publish_1 = strtotime($result1['date_published']);
         $publish_2 = strtotime($result2['date_published']);
         if ($publish_1 < $publish_2) {
            return -1;
         } else if ($publish_1 > $publish_2) {
            return 1;
         } else {
            return 0;
         }
      });
      $results = array_reverse($results);

      echo self::getCVETable($results);
   }

   public static function showForSoftwareVersion(CommonGLPI $item)
   {
      global $DB;

      $software_table = Software::getTable();
      $softwareversion_table = SoftwareVersion::getTable();
      $manufacturer_table = Manufacturer::getTable();
      /*
       *      echo "SELECT $software_table.name AS product, <br>";
       *      echo "$softwareversion_table.name AS version, <br>";
       *      echo "$manufacturer_table.name AS vendor <br>";
       *      echo "FROM $softwareversion_table <br>";
       *      echo "LEFT JOIN  $software_table <br>";
       *      echo "WHERE $softwareversion_table.id = ".$item->getID()."<br>";
       */
      $software_versions = $DB->request([
         'SELECT'    => [
            $software_table.'.id AS internal_id',
            $software_table.'.name AS product',
            $softwareversion_table.'.name AS version',
            $manufacturer_table.'.name AS vendor'
         ],
         'FROM'      => $softwareversion_table,
         'LEFT JOIN' => [
            $software_table => [
               'FKEY'   => [
                  $softwareversion_table  => 'softwares_id',
                  $software_table         => 'id'
               ]
            ],
            $manufacturer_table => [
               'FKEY'   => [
                  $software_table      => 'manufacturers_id',
                  $manufacturer_table  => 'id'
               ]
            ]
         ],
         'WHERE'  => [
            $softwareversion_table.'.id'  => $item->getID()
         ]
      ]);

      $data = $software_versions->current();
      $results = [];
      //var_dump($data);
      if (!empty($data['vendor'])) {
         $cpe_code = PluginCveApi::formCPE2_3String('a', PluginCveApi::formatVendorName($data['vendor']),
                                                    PluginCveApi::formatProductName($data['product']), $data['version']);
         try {
            $cves = PluginCveApi::getCVEForCPE($cpe_code);
         }
         catch(Exception $e) {
            switch($e->getCode()) {
               case 404:
                  echo "API not supported<br>";
                  $cves = [];
                  // TODO try to get information  via  PluginCveApi::getCVEByVendorAndProduct
                  break;
               default:
                  echo "HTTP Code: ".$e->getCode()." returned<br>"; // TODO make this a proper GLPI message
                  $cves = [];
                  break;
            }
         }

         if (count($cves)) {
            $results = self::formatCVEResults($cves, $data['internal_id'], $data['vendor'], $data['product']);
         }
      }

      usort($results, static function($result1, $result2){
         $publish_1 = strtotime($result1['date_published']);
         $publish_2 = strtotime($result2['date_published']);
         if ($publish_1 < $publish_2) {
            return -1;
         } else if ($publish_1 > $publish_2) {
            return 1;
         } else {
            return 0;
         }
      });
      $results = array_reverse($results);

      echo self::getCVETable($results);
   }

   public static function dashboardCards()
   {
      $cards = [];


      $cards["plugin_cve_latest_all"] = [
         'widgettype'  => ['articleList'],
         'label'       => 'Latest CVEs',
         'provider'    => 'PluginCveCve::cardProvider',
      ];

      return $cards;
   }

   public static function cardProvider($name = '', array $params = [])
   {
      $recent = PluginCveApi::getRecentCVE(10);
      $card_data = [];
      foreach ($recent as $data) {
         if(array_key_exists("vulnerabilities", $data)) {
            $card_data[] = [
               'label'     => self::array_get($data, ['vulnerabilities',0,'cve'], "N/A"),
               'content'   => self::array_get($data, ['vulnerabilities',0,'notes',0,'text'], "N/A"),
               'date'      => self::array_get($data, ['vulnerabilities',0,'discovery_date'], "N/A"),
               'author'    => '',
               'url'       => self::array_get($data, ['vulnerabilities',0,'references',0,'url'], "")
            ];
         }
         else {
            //error_log("Card data: ".print_r($data['references'],true), 0);
            $card_data[] = [
               'label'     => self::array_get($data, ['id'], "N/A"),
               'content'   => self::array_get($data, ['summary'], "N/A"),
               'date'      => self::array_get($data, ['published'], "N/A"),
               'author'    => '',
               'url'       => self::array_get($data, ['references',0], ""),
            ];
         }
      }
      return [
         'label' => 'Latest CVEs',
         'data'  => $card_data,
         'number' => 10,
         'url'    => '',
         'icon'   => ''
      ];
   }
}


